<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P4 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P4 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->

<ul style="list-style-type: none;">
	<li>George Hoesch - gah33@pitt.edu</li>
	<li>Alex Glyde - awg13@pitt.edu</li>
</ul>

<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<!-- <p>In this section, broadly overview the types of cryptographic techniques that your group has decided to use to address threats T5–T7.</p> -->

<!-- END CHANGES HERE -->

<img src="../doc/t5_6_gs.png" style="width:1000px;">
<img src="../doc/t5_6_fs.png" style="width:1000px;">
    </section>
    <section id="threat5">
      <h2>Threat T5: Message Reorder, Replay, or Modification</h2>
<!-- BEGIN CHANGES HERE -->

<p>
    Add a sequence number to messages during a single session with the file server or group server. This will prevent messages from being replayed or reordered, because they will be out of order with the number the server is expecting. Furthermore, messages sent during the authentication / handshake phase will be signed and verified by their respective senders / receivers.
</p>
<p>
	Replay:
	<br />
		&nbsp;- Session key prevents OUT OF session replays.
	<br />
		&nbsp;- Sequence numbers prevent IN session replays.
	<br />
	Reorder:
	<br />
		&nbsp;- Sequence numbers prevent reordering of messages.
	<br />
	Modification:
	<br />
		&nbsp;- An HMAC will allow each recipient to verify whether the message has been modified or not. We create HMACs and initialize them using the shared AES session key (see phase3-writeup). Messages sent before the session key is exchanged (i.e., during authentication) are verified using RSA signatures since we do not yet have a shared key.
</p>
<!-- END CHANGES HERE -->
    </section>
    <section id="threat6">
      <h2>Threat T6: File Leakage</h2>
<!-- BEGIN CHANGES HERE -->

<h4>Description of Mechanism</h4>
<p>
	In the GroupList object, the group server will store a HashMap of Group Name strings to an ArrayList of AES keys. The index in the ArrayList will indicate the 'version' of the key (i.e., ArrayList.get(0) will contain the "first" key in the list, and ArrayList.get(ArrayList.size()) will represent the "latest" or "last" key in the list).
</p>
<p>
	When a client requests a token, they will be given another object as well. This object will be a HashMap of String group names to an ArrayList of keys. The group server will only provide group names (and corresponding keys) that the user is a member of.
</p>
<p>
	When a client uploads a new file to the file server, they will encrypt it with the latest version of the AES key for that group, and append the version number to the encrypted file. When a client downloads a file, they will check the version number appended to the file, and decrypt it using the appropriate key corresponding to that version number.
</p>
<p>
	To handle the version numbering, our EncryptionSuite class will have an encryptFile and decryptFile method. Both methods will take a file and an arrayList of keys as parameters. The encryptFile will use the latest key then append the index as the version number to the end of the file. The decryptFile method will remove the appended version number, then use the version number to index the appropriate key to decrypt the file.
</p>
<p>
	When a user is removed from a group or deleted, the group server will generate new keys for all relevant groups (e.g., if a user is deleted, the group server will generate a new key for each group they were a member of).
</p>



<!-- END CHANGES HERE -->
    </section>
    <section id="threat7">
      <h2>Threat T7: Token Theft</h2>
<!-- BEGIN CHANGES HERE -->
<p>
    We are going to create a unique identifier (hash of the public key) that is an immutable field in our token which is unique to the server we're connecting to. So when a token is created, the user will provide the public key hash of a file server they're connecting to. The file server will verify that the public key hash provided in the token is its own. This ensures that a token cannot be used to connect to a DIFFERENT file server than the one that was originally intended.

	When the client initially starts up the application, we request the file server's public key. The client validates whether or not this is the correct public key.
</p>
<!--  The authentication protocol from phase 3 already checks to see if we're connecting to an unauthorized file server so sending a token to an unauthorized file server should not be possible. -->

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>
	We don’t want to hash the encrypted message because then the adversary could modify the encrypted message and recompute the hash since you would be forced to send the hash OUTSIDE of the message itself (e.g., unencrypted);
</p>
<p>
	The first message to the server is not verified by HMAC because that is the message in which the client actually SENDS the key to HMAC messages. Thus, an adversary could potentially forge a message with a different AES key. Instead we sign it with the client's private key which cannot be forged.
</p>
<!-- <p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didn’t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!</p>

<p>Finally, spend about one paragraph convincing me that your modified protocols
still address the threats T1–T4 described in Phase 3 of the project.</p>

<p>If your group did any extra credit, please discuss that in this section, as
well.</p> -->

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>


<!-- <p>Begin this section by describing threat T5. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your group’s implementation from Phase
3.</p>

<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p>

<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>
 -->
