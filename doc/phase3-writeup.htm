<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P3 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired.
 * Be sure your writeup still prints legibly. */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P3 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->
George Hoesch - gah33@pitt.edu
Alex Glyde - awg13@pitt.edu
Ethan Welsh - ejw45@pitt.edu
<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In this section, broadly overview the types of cryptographic techniques that
your group has decided to use to address threats T1â€“T4.</p>

<b>Some assumptions about our system:</b>
<br />
<p>
	We are developing this secure file sharing system for use within a University's research department.
	The users who will have access (via username / password) to the system are PhD professors,
	graduate students, accelling undergraduates, and members of the university's IT department to serve as administrators.
	Professors will (typically, but not exclusively) be the owners of groups, with graduate students and accelling undergraduates
	serving as users.
	To obtain a username and password, one must go through the Professors who will contact
	the IT department to get the user an account.
	All of the public keys and IPs of file servers will be posted on the
	Department's SSL/TLS secured HTTPS website.
</p>
<br />
<p>
	To address the threats from T1-T4 we have implemented ubiquitous encryption for all communications
	across our system. Key exchange is done using public key cryptography and further communications
	are done using AES-256 on a per session basis. Login is done via a username and hashed password.
</p>

<br/> <br/>
<p>
    For the passing of information to be secure we exchange a shared AES key
    between the client and the group/file server using RSA encryption. For the
    rest of the session (the period of time a user is connect to a server) all
    communication is encrypted using that AES Key.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat1">
      <h2>Threat T1: Unauthorized Token Issuance</h2>
<!-- BEGIN CHANGES HERE -->

<p>
	Unauthorized token issuance is equivalent to users being granted unauthorized access to our servers.
	This is problematic because unauthorized users being granted access to tokens that do not belong to them
	compromises our application's ability to discern identity. This results in a potential for adversaries
	to gain access to the compromised user's groups and files. In particular, if an administrator should be
	compromised, the results are particularly egregious due to the fact that administrators have a greater
	degree of privilege.
	In our insecure implementation we make no attempt to prevent unauthorized token issuance. Anyone with
	an account name can receive a token.
</p>

<img src="../doc/t1.png" style="width:750px;">
<br /><br />
<p>
	The client uses the server's public key to encrypt a challenge R, along with their own public key K_c.
	The server generates a new shared AES key K_AES and performs some computation on R.
	It then encrypts both the new shared key K_AES and R+1 and sends them back to the client.
	Next, the user sends back their username and password encrypted with the shared AES key.
	The server checks this password against its salted, SHA-512 database of passwords.
	The user is given three attempts to provide a correct password before their account is locked temporarily
	until they contact an administrator in person.
	This mechanism was chosen to prevent an adversary from attempting to brute-force a user's password.
	If the user's password is validated, the server signs the user's token T using its private key (K_g)^-1
	then encrypts it with the shared AES key and sends it to the user.
	We chose AES-256 because of its suitability for transmitting data quickly and securely.
	Furthermore, it is used pervasively in industry.
	We chose the RSA public key crypto system because its suitable for key-exchange.
</p>

<p>
	Our mechanism addresses the proposed threat because we only issue tokens to users who are
	authenticated via their password which is securely stored on the group server's database.
	The security of our token issuance is equivalent to the security of user's password.
	For this reason, we need to take care to ensure that passwords avoid being compromised,
	are updated frequently, and meet some basic complexity requirements.
</p>
<p>
	In our authentication system, an adversary could foreseeably reach the
	stage where the user is prompted for their password.
	This is why we added a limit on the number of times a user can enter their password incorrectly.
	This prevents brute force attacks and adds to the security of our mechanism.
</p>
<!-- END CHANGES HERE -->
    </section>
    <section id="threat2">
      <h2>Threat T2: Token Modification/Forgery</h2>

<!-- BEGIN CHANGES HERE -->
<p>
	The threat of token modification or forgery is seen when a user receives a token with a certain set of permissions,
	but modifies the token to receive more permissions than they were originally granted.
	This threat is problematic because if a server accepts a token that has been modified by a malicious client,
	the malicious client can then effectively grant themselves arbitrary permissions,
	such as access to the administrator group, owner of the administrator group, and unrestricted access to arbitrary groups and files.
	This compromises the confidentiality and potentially the integrity of our file sharing system.
	In our insecure implementation we make no attempt to verify the validity of a token, or check to see
	if it has been modified.
</p>

<p>
	The mechanism that we chose to implement to protect against this threat can be viewed in the diagram below T1.
	We require that the group server sign and encrypt each token granted to users using a shared AES key
	which is transmitted during the authentication period. This ensures that no passively listening adversaries can see the token,
	and furthermore it prevents the user themselves from modifying the token. Any time an action is requested by the user,
	the server will validate that the token is signed by the group server using the group server's public key.
</p>

<p>
	Our mechanism sufficiently addresses this particular threat because it prevents modification of tokens by users,
	and prevents passively listening adversaries from acquiring an unencrypted token.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat3">
      <h2>Threat T3: Unauthorized File Servers</h2>

<!-- BEGIN CHANGES HERE -->
<p>
	An example of unauthorized file servers manifesting themselves in our insecure implementation
	would be a user accidentally connecting to a file server they had thought was legitimate.
	This would pose a risk because the user could potentially upload sensitive files and information
	to a malicious server.
	In addition to this, the user will probably think that files hosted on this unauthorized server are legitimate.
	This might lead to the user downloading files containing malicious payloads, such as viruses, malware, etc.
</p>

<br /><br />
<img src="../doc/t3.png" style="width:750px;">
<br /><br />
<p>
	To protect against a user connecting to an unauthorized file server, we first make the assumption that
	all authorized file servers, (since they are run by users of our system) will have their public keys
	posted on the department's SSL/TLS secured HTTPS website. This will ensure that we know the IP address,
	and the public key of the file server we are connecting to is legitimate.
</p>
<br />
<p>
	Now, using these assumptions, the client sends the desired file server an initial message containing
	a random number R, the client's public key K_c, and the signed Token [T]K_g^-1 which was received
	from the group server when the user initially connected to the system.
	Next, the file server decrypts the user's message using its private key K_f^-1, and verifies the
	user's token. If the verification fails, communication ceases.
	If the verification succeeds, the file server generates and responds with a shared AES session key,
	along with some previously agreed upon computation on R, proving it was able to decrypt
	the initial message, showing it was the owner of K_f^-1.
	This message containing some computation on R and K_AES is then encrypted using the clients
	public key K_c which was sent in the first message.
	This ensures the client is the only one who can receive the shared AES key.
	At this point, the file server is authorized and the user can carry out operations which are
	encrypted with the shared AES key.
</p>

<p>
	We know based on the assumptions of our system that the public keys of the file servers
	in our system are known and legitimate.
	Thus, since initial communication and shared key exchange is done using encryption with these public keys,
	we can be certain that the shared key will only be known to the client and the respective file server.
	We can be sure both parties agree on the same key as it is generated by the file server, encrypted
	with the client's public key (which is sent in the first message) and then sent to the client.
	This ensures both correctness and security.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat4">
      <h2>Threat T4: Information Leakage via Passive Monitoring</h2>
<!-- BEGIN CHANGES HERE -->
<p>Passive monitoring on data that is not obfuscated presents a risk to the confidentiality of our communications.
	Confidentiality is important because if communications are not hidden,
	then tokens, files, passwords, and group server actions are all transparent to any listening entity.
	This violates the user's privacy and poses security risks to the integrity of the system.
	In particular, monitoring of tokens is especially problematic for reasons previously mentioned in T1.
	In our insecure implementation we do not make any attempt to encrypt or obfuscate communications
	so all information would be leaked.
</p>


<p>
	The mechanism we chose to implement to protect against this threat can be viewed in the diagram below T1.
	We chose to use a shared AES-256 key as we believed it to currently be the standard in secure data transmission.
	We exchanged shared AES keys via the server and client's public RSA keys. The client generates
	a shared AES key and shares it with the server after encrypting it with the group server's public key,
	as can be seen in T1.
</p>
<p>
	Our proposed mechanism sufficiently addresses the threat because at no point would an adversary be able to access a shared key.
	The shared keys are transmitted using RSA encryption at the authentication stage.
	Furthermore, passively monitoring adversaries would only see encrypted information being communicated between the server's and client.
	Because of this, all communications are hidden from outside observers.
	This ensures that file contents remain private, and that tokens cannot be stolen in transit.
</p>

<p>Begin this section by describing threat T1. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your groupâ€™s insecure
implementation.</p>

<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p>

<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didnâ€™t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!</p>


<p>If your group did any extra credit, please discuss that in this section, as
well.</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>
